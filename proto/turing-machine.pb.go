// Code generated by protoc-gen-go. DO NOT EDIT.
// source: turing-machine.proto

/*
Package turing_machine is a generated protocol buffer package.

Data model for the Turing Machine.

It is generated from these files:
	turing-machine.proto

It has these top-level messages:
	InitializeRequest
	Empty
	Halted
	Run
	Config
	Rpc
	TuringMachine
*/
package turing_machine

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Move the head one cell to the left or right
type HeadMove int32

const (
	HeadMove_LEFT  HeadMove = 0
	HeadMove_RIGHT HeadMove = 1
)

var HeadMove_name = map[int32]string{
	0: "LEFT",
	1: "RIGHT",
}
var HeadMove_value = map[string]int32{
	"LEFT":  0,
	"RIGHT": 1,
}

func (x HeadMove) String() string {
	return proto.EnumName(HeadMove_name, int32(x))
}
func (HeadMove) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type InitializeRequest struct {
	// The string with which the tape shall be initialized. The
	// leftmost symbol will be at tape coordinateÂ 0.
	// @inject_tag: xml:"tape-content"
	TapeContent string `protobuf:"bytes,1,opt,name=tape_content,json=tapeContent" json:"tape_content,omitempty" xml:"tape-content"`
}

func (m *InitializeRequest) Reset()                    { *m = InitializeRequest{} }
func (m *InitializeRequest) String() string            { return proto.CompactTextString(m) }
func (*InitializeRequest) ProtoMessage()               {}
func (*InitializeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *InitializeRequest) GetTapeContent() string {
	if m != nil {
		return m.TapeContent
	}
	return ""
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// The Turing Machine has halted. This means that there is no
// transition rule for the current state and tape symbol.
type Halted struct {
	// The state of the control unit in which the machine has
	// halted.
	State uint32 `protobuf:"varint,1,opt,name=state" json:"state,omitempty"`
}

func (m *Halted) Reset()                    { *m = Halted{} }
func (m *Halted) String() string            { return proto.CompactTextString(m) }
func (*Halted) ProtoMessage()               {}
func (*Halted) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Halted) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

// Start the Turing Machine operation.
type Run struct {
}

func (m *Run) Reset()                    { *m = Run{} }
func (m *Run) String() string            { return proto.CompactTextString(m) }
func (*Run) ProtoMessage()               {}
func (*Run) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// Config data
type Config struct {
	// @inject_tag: xml:"xmlns,attr"
	Xmlns string `protobuf:"bytes,1,opt,name=xmlns" json:"xmlns,omitempty" xml:"xmlns,attr"`
	// @inject_tag: xml:"turing-machine"
	TuringMachine *TuringMachine `protobuf:"bytes,2,opt,name=turing_machine,json=turingMachine" json:"turing_machine,omitempty" xml:"turing-machine"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Config) GetXmlns() string {
	if m != nil {
		return m.Xmlns
	}
	return ""
}

func (m *Config) GetTuringMachine() *TuringMachine {
	if m != nil {
		return m.TuringMachine
	}
	return nil
}

// Initialize Request RPC
type Rpc struct {
	// @inject_tag: xml:"message-id,attr"
	MessageId uint32 `protobuf:"varint,1,opt,name=messageId" json:"messageId,omitempty" xml:"message-id,attr"`
	// @inject_tag: xml:"initialize"
	Initialize *InitializeRequest `protobuf:"bytes,2,opt,name=initialize" json:"initialize,omitempty" xml:"initialize"`
}

func (m *Rpc) Reset()                    { *m = Rpc{} }
func (m *Rpc) String() string            { return proto.CompactTextString(m) }
func (*Rpc) ProtoMessage()               {}
func (*Rpc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Rpc) GetMessageId() uint32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *Rpc) GetInitialize() *InitializeRequest {
	if m != nil {
		return m.Initialize
	}
	return nil
}

// State data and configuration of a Turing Machine.
type TuringMachine struct {
	// Position of tape read/write head.
	// @inject_tag: xml:"head-position"
	HeadPosition int64 `protobuf:"varint,1,opt,name=head_position,json=headPosition" json:"head_position,omitempty" xml:"head-position"`
	// Current state of the control unit.
	// The initial state is 0.
	// @inject_tag: xml:"state"
	State uint32 `protobuf:"varint,2,opt,name=state" json:"state,omitempty" xml:"state"`
	// @inject_tag: xml:"tape"
	Tape *TuringMachine_Tape `protobuf:"bytes,3,opt,name=tape" json:"tape,omitempty" xml:"tape"`
	// @inject_tag: xml:"transition-function"
	TransitionFunction *TuringMachine_TransitionFunction `protobuf:"bytes,4,opt,name=transition_function,json=transitionFunction" json:"transition_function,omitempty" xml:"transition-function"`
}

func (m *TuringMachine) Reset()                    { *m = TuringMachine{} }
func (m *TuringMachine) String() string            { return proto.CompactTextString(m) }
func (*TuringMachine) ProtoMessage()               {}
func (*TuringMachine) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *TuringMachine) GetHeadPosition() int64 {
	if m != nil {
		return m.HeadPosition
	}
	return 0
}

func (m *TuringMachine) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *TuringMachine) GetTape() *TuringMachine_Tape {
	if m != nil {
		return m.Tape
	}
	return nil
}

func (m *TuringMachine) GetTransitionFunction() *TuringMachine_TransitionFunction {
	if m != nil {
		return m.TransitionFunction
	}
	return nil
}

// The contents of the tape.
type TuringMachine_Tape struct {
	// @inject_tag: xml:"cell"
	Cell []*TuringMachine_Tape_Cell `protobuf:"bytes,1,rep,name=cell" json:"cell,omitempty" xml:"cell"`
}

func (m *TuringMachine_Tape) Reset()                    { *m = TuringMachine_Tape{} }
func (m *TuringMachine_Tape) String() string            { return proto.CompactTextString(m) }
func (*TuringMachine_Tape) ProtoMessage()               {}
func (*TuringMachine_Tape) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

func (m *TuringMachine_Tape) GetCell() []*TuringMachine_Tape_Cell {
	if m != nil {
		return m.Cell
	}
	return nil
}

// List of non-blank cells.
type TuringMachine_Tape_Cell struct {
	// Coordinate (index) of the tape cell.
	// @inject_tag: xml:"coord"
	Coord int64 `protobuf:"varint,1,opt,name=coord" json:"coord,omitempty" xml:"coord"`
	// Symbol appearing in the tape cell.
	// Blank (empty string) is not allowed here because the
	// 'cell' list only contains non-blank cells.
	// @inject_tag: xml:"symbol"
	Symbol string `protobuf:"bytes,2,opt,name=symbol" json:"symbol,omitempty" xml:"symbol"`
}

func (m *TuringMachine_Tape_Cell) Reset()                    { *m = TuringMachine_Tape_Cell{} }
func (m *TuringMachine_Tape_Cell) String() string            { return proto.CompactTextString(m) }
func (*TuringMachine_Tape_Cell) ProtoMessage()               {}
func (*TuringMachine_Tape_Cell) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0, 0} }

func (m *TuringMachine_Tape_Cell) GetCoord() int64 {
	if m != nil {
		return m.Coord
	}
	return 0
}

func (m *TuringMachine_Tape_Cell) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

// The Turing Machine is configured by specifying the
// transition function.
type TuringMachine_TransitionFunction struct {
	// @inject_tag: xml:"delta"
	Delta []*TuringMachine_TransitionFunction_Delta `protobuf:"bytes,1,rep,name=delta" json:"delta,omitempty" xml:"delta"`
}

func (m *TuringMachine_TransitionFunction) Reset()         { *m = TuringMachine_TransitionFunction{} }
func (m *TuringMachine_TransitionFunction) String() string { return proto.CompactTextString(m) }
func (*TuringMachine_TransitionFunction) ProtoMessage()    {}
func (*TuringMachine_TransitionFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 1}
}

func (m *TuringMachine_TransitionFunction) GetDelta() []*TuringMachine_TransitionFunction_Delta {
	if m != nil {
		return m.Delta
	}
	return nil
}

// The list of transition rules.
type TuringMachine_TransitionFunction_Delta struct {
	// @inject_tag: xml:"input"
	Input *TuringMachine_TransitionFunction_Delta_Input `protobuf:"bytes,1,opt,name=input" json:"input,omitempty" xml:"input"`
	// An arbitrary label of the transition rule.
	// @inject_tag: xml:"label"
	Label string `protobuf:"bytes,2,opt,name=label" json:"label,omitempty" xml:"label"`
	// @inject_tag: xml:"output"
	Output *TuringMachine_TransitionFunction_Delta_Output `protobuf:"bytes,3,opt,name=output" json:"output,omitempty" xml:"output"`
}

func (m *TuringMachine_TransitionFunction_Delta) Reset() {
	*m = TuringMachine_TransitionFunction_Delta{}
}
func (m *TuringMachine_TransitionFunction_Delta) String() string { return proto.CompactTextString(m) }
func (*TuringMachine_TransitionFunction_Delta) ProtoMessage()    {}
func (*TuringMachine_TransitionFunction_Delta) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 1, 0}
}

func (m *TuringMachine_TransitionFunction_Delta) GetInput() *TuringMachine_TransitionFunction_Delta_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *TuringMachine_TransitionFunction_Delta) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *TuringMachine_TransitionFunction_Delta) GetOutput() *TuringMachine_TransitionFunction_Delta_Output {
	if m != nil {
		return m.Output
	}
	return nil
}

// Input parameters (arguments) of the transition rule.
type TuringMachine_TransitionFunction_Delta_Input struct {
	// Current state of the control unit.
	// @inject_tag: xml:"state"
	State uint32 `protobuf:"varint,1,opt,name=state" json:"state,omitempty" xml:"state"`
	// Symbol read from the tape cell.
	// @inject_tag: xml:"symbol"
	Symbol string `protobuf:"bytes,2,opt,name=symbol" json:"symbol,omitempty" xml:"symbol"`
}

func (m *TuringMachine_TransitionFunction_Delta_Input) Reset() {
	*m = TuringMachine_TransitionFunction_Delta_Input{}
}
func (m *TuringMachine_TransitionFunction_Delta_Input) String() string {
	return proto.CompactTextString(m)
}
func (*TuringMachine_TransitionFunction_Delta_Input) ProtoMessage() {}
func (*TuringMachine_TransitionFunction_Delta_Input) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 1, 0, 0}
}

func (m *TuringMachine_TransitionFunction_Delta_Input) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *TuringMachine_TransitionFunction_Delta_Input) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

// Output values of the transition rule.
type TuringMachine_TransitionFunction_Delta_Output struct {
	// HeadMove head_move = 1;
	// @inject_tag: xml:"head-move"
	HeadMove string `protobuf:"bytes,1,opt,name=head_move,json=headMove" json:"head_move,omitempty" xml:"head-move"`
	// New state of the control unit. If this leaf is not
	// present, the state doesn't change.
	// @inject_tag: xml:"state"
	State uint32 `protobuf:"varint,2,opt,name=state" json:"state,omitempty" xml:"state"`
	// Symbol to be written to the tape cell. If this leaf is
	// not present, the symbol doesn't change.
	// @inject_tag: xml:"symbol"
	Symbol string `protobuf:"bytes,3,opt,name=symbol" json:"symbol,omitempty" xml:"symbol"`
}

func (m *TuringMachine_TransitionFunction_Delta_Output) Reset() {
	*m = TuringMachine_TransitionFunction_Delta_Output{}
}
func (m *TuringMachine_TransitionFunction_Delta_Output) String() string {
	return proto.CompactTextString(m)
}
func (*TuringMachine_TransitionFunction_Delta_Output) ProtoMessage() {}
func (*TuringMachine_TransitionFunction_Delta_Output) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 1, 0, 1}
}

func (m *TuringMachine_TransitionFunction_Delta_Output) GetHeadMove() string {
	if m != nil {
		return m.HeadMove
	}
	return ""
}

func (m *TuringMachine_TransitionFunction_Delta_Output) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *TuringMachine_TransitionFunction_Delta_Output) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func init() {
	proto.RegisterType((*InitializeRequest)(nil), "turing_machine.InitializeRequest")
	proto.RegisterType((*Empty)(nil), "turing_machine.Empty")
	proto.RegisterType((*Halted)(nil), "turing_machine.Halted")
	proto.RegisterType((*Run)(nil), "turing_machine.Run")
	proto.RegisterType((*Config)(nil), "turing_machine.Config")
	proto.RegisterType((*Rpc)(nil), "turing_machine.Rpc")
	proto.RegisterType((*TuringMachine)(nil), "turing_machine.TuringMachine")
	proto.RegisterType((*TuringMachine_Tape)(nil), "turing_machine.TuringMachine.Tape")
	proto.RegisterType((*TuringMachine_Tape_Cell)(nil), "turing_machine.TuringMachine.Tape.Cell")
	proto.RegisterType((*TuringMachine_TransitionFunction)(nil), "turing_machine.TuringMachine.TransitionFunction")
	proto.RegisterType((*TuringMachine_TransitionFunction_Delta)(nil), "turing_machine.TuringMachine.TransitionFunction.Delta")
	proto.RegisterType((*TuringMachine_TransitionFunction_Delta_Input)(nil), "turing_machine.TuringMachine.TransitionFunction.Delta.Input")
	proto.RegisterType((*TuringMachine_TransitionFunction_Delta_Output)(nil), "turing_machine.TuringMachine.TransitionFunction.Delta.Output")
	proto.RegisterEnum("turing_machine.HeadMove", HeadMove_name, HeadMove_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TuringMachineRpc service

type TuringMachineRpcClient interface {
	Configure(ctx context.Context, in *Config, opts ...grpc.CallOption) (*Empty, error)
	Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*Empty, error)
	Run(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Halted, error)
	GetState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TuringMachine, error)
}

type turingMachineRpcClient struct {
	cc *grpc.ClientConn
}

func NewTuringMachineRpcClient(cc *grpc.ClientConn) TuringMachineRpcClient {
	return &turingMachineRpcClient{cc}
}

func (c *turingMachineRpcClient) Configure(ctx context.Context, in *Config, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/turing_machine.TuringMachineRpc/Configure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *turingMachineRpcClient) Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/turing_machine.TuringMachineRpc/Initialize", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *turingMachineRpcClient) Run(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Halted, error) {
	out := new(Halted)
	err := grpc.Invoke(ctx, "/turing_machine.TuringMachineRpc/Run", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *turingMachineRpcClient) GetState(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TuringMachine, error) {
	out := new(TuringMachine)
	err := grpc.Invoke(ctx, "/turing_machine.TuringMachineRpc/GetState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TuringMachineRpc service

type TuringMachineRpcServer interface {
	Configure(context.Context, *Config) (*Empty, error)
	Initialize(context.Context, *InitializeRequest) (*Empty, error)
	Run(context.Context, *Empty) (*Halted, error)
	GetState(context.Context, *Empty) (*TuringMachine, error)
}

func RegisterTuringMachineRpcServer(s *grpc.Server, srv TuringMachineRpcServer) {
	s.RegisterService(&_TuringMachineRpc_serviceDesc, srv)
}

func _TuringMachineRpc_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TuringMachineRpcServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/turing_machine.TuringMachineRpc/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TuringMachineRpcServer).Configure(ctx, req.(*Config))
	}
	return interceptor(ctx, in, info, handler)
}

func _TuringMachineRpc_Initialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitializeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TuringMachineRpcServer).Initialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/turing_machine.TuringMachineRpc/Initialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TuringMachineRpcServer).Initialize(ctx, req.(*InitializeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TuringMachineRpc_Run_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TuringMachineRpcServer).Run(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/turing_machine.TuringMachineRpc/Run",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TuringMachineRpcServer).Run(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TuringMachineRpc_GetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TuringMachineRpcServer).GetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/turing_machine.TuringMachineRpc/GetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TuringMachineRpcServer).GetState(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _TuringMachineRpc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "turing_machine.TuringMachineRpc",
	HandlerType: (*TuringMachineRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Configure",
			Handler:    _TuringMachineRpc_Configure_Handler,
		},
		{
			MethodName: "Initialize",
			Handler:    _TuringMachineRpc_Initialize_Handler,
		},
		{
			MethodName: "Run",
			Handler:    _TuringMachineRpc_Run_Handler,
		},
		{
			MethodName: "GetState",
			Handler:    _TuringMachineRpc_GetState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "turing-machine.proto",
}

func init() { proto.RegisterFile("turing-machine.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 587 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xe9, 0x6e, 0xd3, 0x4c,
	0x14, 0xfd, 0x12, 0x2f, 0x5f, 0x7c, 0xd3, 0xa0, 0x32, 0x94, 0x2a, 0x32, 0x5b, 0x6b, 0x7e, 0x50,
	0x21, 0x61, 0xa1, 0x50, 0xfa, 0x83, 0x45, 0x02, 0x75, 0x4b, 0xa4, 0x56, 0xa0, 0x69, 0xf8, 0x1d,
	0x4d, 0xec, 0x49, 0x6a, 0xc9, 0x9e, 0x31, 0xf1, 0xb8, 0x22, 0x3c, 0x04, 0x4f, 0xc0, 0x8b, 0xf0,
	0x1e, 0x3c, 0x10, 0x9a, 0x25, 0xcd, 0x46, 0x1a, 0xd1, 0x9f, 0xe7, 0x78, 0xee, 0xb9, 0xe7, 0x1e,
	0xcf, 0x5c, 0xd8, 0x12, 0xe5, 0x28, 0x61, 0xc3, 0x17, 0x19, 0x89, 0x2e, 0x13, 0x46, 0xc3, 0x7c,
	0xc4, 0x05, 0x47, 0x77, 0x34, 0xdb, 0x33, 0x6c, 0x70, 0x00, 0x77, 0x3b, 0x2c, 0x11, 0x09, 0x49,
	0x93, 0xef, 0x14, 0xd3, 0xaf, 0x25, 0x2d, 0x04, 0xda, 0x85, 0x0d, 0x41, 0x72, 0xda, 0x8b, 0x38,
	0x13, 0x94, 0x89, 0x66, 0x65, 0xa7, 0xb2, 0xe7, 0xe1, 0xba, 0xe4, 0x0e, 0x35, 0x15, 0xfc, 0x0f,
	0xce, 0x71, 0x96, 0x8b, 0x71, 0xf0, 0x18, 0xdc, 0x36, 0x49, 0x05, 0x8d, 0xd1, 0x16, 0x38, 0x85,
	0x20, 0x82, 0xaa, 0xe3, 0x0d, 0xac, 0x41, 0xe0, 0x80, 0x85, 0x4b, 0x16, 0xc4, 0xe0, 0x1e, 0x72,
	0x36, 0x48, 0x86, 0xf2, 0xd8, 0xb7, 0x2c, 0x65, 0x85, 0x51, 0xd5, 0x00, 0x1d, 0xc1, 0x82, 0xb3,
	0x66, 0x75, 0xa7, 0xb2, 0x57, 0x6f, 0x3d, 0x0a, 0xe7, 0xe9, 0xb0, 0xab, 0xe0, 0xb9, 0x46, 0xb8,
	0x21, 0x66, 0x61, 0x30, 0x00, 0x0b, 0xe7, 0x11, 0x7a, 0x08, 0x5e, 0x46, 0x8b, 0x82, 0x0c, 0x69,
	0x27, 0x36, 0x6e, 0xa6, 0x04, 0xfa, 0x08, 0x90, 0x5c, 0x8f, 0x6c, 0xda, 0xec, 0x2e, 0xb6, 0x59,
	0x0a, 0x05, 0xcf, 0x14, 0x05, 0x3f, 0x5d, 0x68, 0xcc, 0x19, 0x41, 0x4f, 0xa1, 0x71, 0x49, 0x49,
	0xdc, 0xcb, 0x79, 0x91, 0x88, 0x84, 0x33, 0xd5, 0xd6, 0xc2, 0x1b, 0x92, 0xfc, 0x6c, 0xb8, 0x69,
	0x42, 0xd5, 0x99, 0x84, 0xd0, 0x01, 0xd8, 0x32, 0xd9, 0xa6, 0xa5, 0x9c, 0x04, 0x37, 0x0e, 0x1c,
	0x76, 0x49, 0x4e, 0xb1, 0x3a, 0x8f, 0x08, 0xdc, 0x13, 0x23, 0xc2, 0xb4, 0x76, 0x6f, 0x50, 0xb2,
	0x48, 0x35, 0xb6, 0x95, 0xcc, 0xcb, 0x35, 0x32, 0xd7, 0x85, 0x27, 0xa6, 0x0e, 0x23, 0xb1, 0xc4,
	0xf9, 0x63, 0xb0, 0x65, 0x43, 0xf4, 0x16, 0xec, 0x88, 0xa6, 0x69, 0xb3, 0xb2, 0x63, 0xed, 0xd5,
	0x5b, 0xcf, 0xd6, 0x5b, 0x0c, 0x0f, 0x69, 0x9a, 0x62, 0x55, 0xe4, 0xef, 0x83, 0x2d, 0x91, 0x9c,
	0x3e, 0xe2, 0x7c, 0x14, 0x9b, 0x68, 0x34, 0x40, 0xdb, 0xe0, 0x16, 0xe3, 0xac, 0xcf, 0x53, 0x15,
	0x8a, 0x87, 0x0d, 0xf2, 0x7f, 0x59, 0x80, 0x96, 0x5d, 0xa2, 0x33, 0x70, 0x62, 0x9a, 0x0a, 0x62,
	0xac, 0x1c, 0xfc, 0xeb, 0x98, 0xe1, 0x91, 0xac, 0xc6, 0x5a, 0xc4, 0xff, 0x5d, 0x05, 0x47, 0x11,
	0x08, 0x83, 0x93, 0xb0, 0xbc, 0xd4, 0x77, 0xbd, 0xde, 0x7a, 0x77, 0x3b, 0xdd, 0xb0, 0x23, 0x35,
	0xb0, 0x96, 0x92, 0x03, 0xa7, 0xa4, 0x4f, 0x27, 0x93, 0x69, 0x80, 0xbe, 0x80, 0xcb, 0x4b, 0x21,
	0x5b, 0xe9, 0x1f, 0xfe, 0xfe, 0x96, 0xad, 0x3e, 0x29, 0x11, 0x6c, 0xc4, 0xfc, 0xd7, 0xe0, 0x74,
	0x26, 0x5d, 0x97, 0x9f, 0xe1, 0xca, 0x98, 0x2f, 0xc0, 0xd5, 0x42, 0xe8, 0x01, 0x78, 0xea, 0x06,
	0x67, 0xfc, 0x8a, 0x9a, 0xb7, 0x59, 0x93, 0xc4, 0x39, 0xbf, 0xa2, 0x2b, 0x6e, 0xee, 0x54, 0xd4,
	0x9a, 0x15, 0x7d, 0xfe, 0x04, 0x6a, 0xed, 0x49, 0x65, 0x0d, 0xec, 0xb3, 0xe3, 0x93, 0xee, 0xe6,
	0x7f, 0xc8, 0x03, 0x07, 0x77, 0x4e, 0xdb, 0xdd, 0xcd, 0x4a, 0xeb, 0x47, 0x15, 0x36, 0xe7, 0x1f,
	0x72, 0x1e, 0xa1, 0x37, 0xe0, 0xe9, 0x15, 0x51, 0x8e, 0x28, 0xda, 0x5e, 0x4c, 0x45, 0x7f, 0xf2,
	0xef, 0x2f, 0xf2, 0x6a, 0x0b, 0xa1, 0x13, 0x80, 0xe9, 0x8b, 0x45, 0xeb, 0x5f, 0xf3, 0x2a, 0x9d,
	0x7d, 0xb5, 0xad, 0xd0, 0xdf, 0xbf, 0xfa, 0x4b, 0xa6, 0xcc, 0xe6, 0xfb, 0x00, 0xb5, 0x53, 0x2a,
	0x2e, 0x54, 0x26, 0x2b, 0x4a, 0x6f, 0xde, 0x63, 0x7d, 0x57, 0x6d, 0xe7, 0x57, 0x7f, 0x02, 0x00,
	0x00, 0xff, 0xff, 0x23, 0x1c, 0xbc, 0xad, 0xb5, 0x05, 0x00, 0x00,
}
